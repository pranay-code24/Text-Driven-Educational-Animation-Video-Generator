name: Video Renderer

on:
  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      video_id:
        description: 'Video ID to render'
        required: false
        type: string

  # Scheduled run every 5 minutes to check for queued videos
  schedule:
    - cron: '*/5 * * * *'

  # Repository dispatch from API server
  repository_dispatch:
    types: [render_video]

jobs:
  render-video:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          ffmpeg \
          libcairo2-dev \
          libpango1.0-dev \
          ffmpeg \
          texlive-latex-base \
          texlive-fonts-recommended \
          texlive-extra-utils \
          texlive-latex-extra \
          dvipng

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-github-actions.txt

    - name: Set up environment variables
      run: |
        echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}" >> $GITHUB_ENV
        echo "APPWRITE_API_KEY=${{ secrets.APPWRITE_API_KEY }}" >> $GITHUB_ENV
        echo "APPWRITE_PROJECT_ID=${{ secrets.APPWRITE_PROJECT_ID }}" >> $GITHUB_ENV
        echo "APPWRITE_ENDPOINT=${{ secrets.APPWRITE_ENDPOINT }}" >> $GITHUB_ENV
        echo "GITHUB_REPO_OWNER=${{ github.repository_owner }}" >> $GITHUB_ENV
        echo "GITHUB_REPO_NAME=${{ github.event.repository.name }}" >> $GITHUB_ENV
        echo "GH_PAT=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_ENV

    - name: Check for videos to render
      id: check_videos
      run: |
        python -c "
        import os
        import sys
        sys.path.append('src')

        from src.core.appwrite_integration import AppwriteVideoManager
        import asyncio

        async def check_and_render():
            manager = AppwriteVideoManager()
            if not manager.enabled:
                print('Appwrite not configured')
                return

            # Get videos that need rendering
            videos = await manager.list_videos(status='queued_for_render')
            if not videos:
                print('No videos queued for rendering')
                return

            # Take the first video
            video = videos[0]
            video_id = video['\$id']
            print(f'Found video to render: {video_id}')

            # Update status to rendering
            await manager.update_video_status(video_id, 'rendering', 'Starting video rendering...')

            # Set output for next step
            print(f'::set-output name=video_id::{video_id}')
            print(f'::set-output name=topic::{video.get(\"topic\", \"Unknown\")}')

        asyncio.run(check_and_render())
        "
      continue-on-error: true

    - name: Render video
      if: steps.check_videos.outputs.video_id != ''
      run: |
        VIDEO_ID='${{ steps.check_videos.outputs.video_id }}'
        TOPIC='${{ steps.check_videos.outputs.topic }}'

        echo "Rendering video: $VIDEO_ID - $TOPIC"

        python -c "
        import os
        import sys
        sys.path.append('src')

        from src.core.appwrite_integration import AppwriteVideoManager
        from generate_video import VideoGenerator
        from mllm_tools.litellm import LiteLLMWrapper
        from src.config.config import Config
        import asyncio

        async def render_video():
            video_id = os.environ.get('VIDEO_ID')
            if not video_id:
                print('No video ID provided')
                return

            print(f'Starting render for video: {video_id}')

            # Initialize Appwrite manager
            manager = AppwriteVideoManager()
            if not manager.enabled:
                print('Appwrite not configured')
                return

            # Get video details
            video = await manager.get_video_record(video_id)
            if not video:
                print(f'Video {video_id} not found')
                return

            topic = video.get('topic', 'Unknown Topic')
            description = video.get('description', '')
            scene_count = video.get('scene_count', 3)

            print(f'Rendering: {topic} ({scene_count} scenes)')

            try:
                # Initialize video generator
                planner_model = LiteLLMWrapper(
                    model_name=Config.DEFAULT_PLANNER_MODEL,
                    temperature=Config.DEFAULT_MODEL_TEMPERATURE,
                    print_cost=Config.MODEL_PRINT_COST,
                    verbose=Config.MODEL_VERBOSE,
                    use_langfuse=Config.USE_LANGFUSE
                )

                generator = VideoGenerator(
                    planner_model=planner_model,
                    helper_model=planner_model,
                    scene_model=planner_model,
                    output_dir='output',
                    verbose=True
                )

                # Generate video
                result = await generator.generate_video_pipeline(
                    topic=topic,
                    description=description,
                    max_retries=2,
                    only_plan=False,
                    specific_scenes=list(range(1, scene_count + 1))
                )

                if result and result.get('success'):
                    # Upload final video
                    video_file = result.get('combined_video_path')
                    if video_file and os.path.exists(video_file):
                        file_id = await manager.upload_video_file(video_file, video_id)
                        if file_id:
                            video_url = manager._get_file_url(manager.final_videos_bucket_id, file_id)
                            await manager.update_video_status(
                                video_id,
                                'completed',
                                combined_video_url=video_url
                            )
                            print(f'✅ Video completed: {video_url}')
                        else:
                            await manager.update_video_status(
                                video_id,
                                'failed',
                                'Failed to upload video file'
                            )
                    else:
                        await manager.update_video_status(
                            video_id,
                            'failed',
                            'Video file not generated'
                        )
                else:
                    error_msg = result.get('error', 'Unknown error during generation') if result else 'Generation failed'
                    await manager.update_video_status(video_id, 'failed', error_msg)
                    print(f'❌ Video generation failed: {error_msg}')

            except Exception as e:
                error_msg = f'Render error: {str(e)}'
                await manager.update_video_status(video_id, 'failed', error_msg)
                print(f'❌ Exception during render: {error_msg}')

        asyncio.run(render_video())
        "
      env:
        VIDEO_ID: ${{ steps.check_videos.outputs.video_id }}
        TOPIC: ${{ steps.check_videos.outputs.topic }}

    - name: Upload render logs
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: render-logs-${{ steps.check_videos.outputs.video_id || 'no-video' }}
        path: |
          *.log
          output/
        retention-days: 7
